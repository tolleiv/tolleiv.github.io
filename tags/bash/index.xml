<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blog.tolleiv.de ...  </title>
    <link>https://blog.tolleiv.de/tags/bash/index.xml</link>
    <description>Recent content on blog.tolleiv.de ...  </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/tolleiv&#34;&gt;tolleiv&lt;/a&gt; 2016 - &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/3.0/&#34;&gt;CC BY-SA 3.0&lt;/a&gt; - Powered by Hugo</copyright>
    <atom:link href="https://blog.tolleiv.de/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>bash: small improvement for the &#34;cd&#34; builtin</title>
      <link>https://blog.tolleiv.de/2009/06/bash-small-improvement-for-the-cd-builtin/</link>
      <pubDate>Thu, 18 Jun 2009 21:54:34 +0000</pubDate>
      
      <guid>https://blog.tolleiv.de/2009/06/bash-small-improvement-for-the-cd-builtin/</guid>
      <description>&lt;p&gt;If you use the shell and walk around in directories wouldn&amp;rsquo;t it be cool to have &amp;ldquo;cd &amp;hellip;&amp;rdquo; to move 2 levels up, &amp;ldquo;cd &amp;hellip;.&amp;rdquo; to move 3 levels up &amp;hellip;? I&amp;rsquo;m not sure if there&amp;rsquo;s an easier way to resolve it but the following lines work pretty nice so far and they just made it into my default .bashrc :P&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd() {
    if [[ &amp;quot;$1&amp;quot; =~ ^\.\.\.+$  ]]; then
        cd `echo &amp;quot;$1&amp;quot; | sed &#39;s/\./..\//g&#39; | sed &#39;s/^\.\.\///g&#39;`
    else
        builtin cd &amp;quot;$1&amp;quot;
    fi
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For different older shell/bash versions you might need quotes around the regex.&lt;/p&gt;

&lt;p&gt;Btw &lt;a href=&#34;http://books.google.de/books?id=WQCSxv9vfPkC&amp;amp;lpg=PA84&amp;amp;ots=OiT8hUe10J&amp;amp;dq=bash%20function%20with%20the%20same%20name%20as%20command&amp;amp;pg=PP1&#34;&gt;O&amp;rsquo;Reilly&amp;rsquo;s &amp;ldquo;Learning the Bash&amp;rdquo;&lt;/a&gt; is available within Google Books&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Edit: another very important bookmark for bashscripting is the &lt;a href=&#34;http://tldp.org/LDP/abs/html/&#34;&gt;Advanced Bash-Scripting Guide&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shell command: translate </title>
      <link>https://blog.tolleiv.de/2009/04/shell-command-translate/</link>
      <pubDate>Tue, 28 Apr 2009 16:22:55 +0000</pubDate>
      
      <guid>https://blog.tolleiv.de/2009/04/shell-command-translate/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Translate, squeeze, and/or delete characters from standard input,
writing to standard output.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip; that&amp;rsquo;s the manpage description of the shell-command I just found (with the help of a good friend) &amp;hellip; and besides sed this is a very handy way to do simple string-operations on stdin.&lt;/p&gt;

&lt;p&gt;He used it to replace (old) Mac newline characters with Unix newline charaters within files (as seen on &lt;a href=&#34;http://en.wikipedia.org/wiki/Newline&#34;&gt;wikipedia&lt;/a&gt;):
&lt;code&gt;tr &#39;\r&#39; &#39;\n&#39; &amp;lt; old.file &amp;gt; new.file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Btw I still think that it&amp;rsquo;s stupid that users still have all the hazzle with &lt;a href=&#34;http://en.wikipedia.org/wiki/Newline&#34;&gt;newline charaters&lt;/a&gt; - why can&amp;rsquo;t the OS-developers just recognize all types of newlines? :(&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>find the newest file within a folder....</title>
      <link>https://blog.tolleiv.de/2009/04/find-the-newest-file-within-a-folder..../</link>
      <pubDate>Tue, 14 Apr 2009 20:14:42 +0000</pubDate>
      
      <guid>https://blog.tolleiv.de/2009/04/find-the-newest-file-within-a-folder..../</guid>
      <description>&lt;p&gt;These are two neat little commands to find the newest and oldest file within a folder and it&amp;rsquo;s subfolder:
&lt;code&gt;find . -type f -printf &amp;quot;%T@ %p \n&amp;quot; | sort -n -k 1,1 | awk &#39;{print $2}&#39; | tail -n 1
find . -type f -printf &amp;quot;%T@ %p \n&amp;quot; | sort -n -k 1,1 | awk &#39;{print $2}&#39; | head -n 1&lt;/code&gt;
If you&amp;rsquo;d like to know how old/young these files are try these two:
&lt;code&gt;find . -type f -printf &amp;quot;%T@ %C+ %p \n&amp;quot; | sort -n -k 1,1 | tail -n 1
find . -type f -printf &amp;quot;%T@ %C+ %p \n&amp;quot; | sort -n -k 1,1 | head -n 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I hope that&amp;rsquo;s a good starter for the &amp;ldquo;blog&amp;rdquo; :P&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>track time for a subroutine within a shell-script</title>
      <link>https://blog.tolleiv.de/2008/07/track-time-for-a-subroutine-within-a-shell-script/</link>
      <pubDate>Thu, 10 Jul 2008 21:55:00 +0000</pubDate>
      
      <guid>https://blog.tolleiv.de/2008/07/track-time-for-a-subroutine-within-a-shell-script/</guid>
      <description>&lt;p&gt;The following code-snippet is a shell-script which does the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Track the time for a block of shell commands&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if the time was less than x seconds (the example uses 10 seconds)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the block run through too fast the script waits/sleeps a few seconds&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run all this within a loop so that the block of shell-commands is executed periodically&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I used the script combined with a PHP script which processes a queue. The PHP script processes 1000 elements from the queue and takes about 30 seconds for that. Since just having a cronjob per minute would be not efficient enought I used this script.
The waiting-block is necessary because now and then the queue is empty &amp;hellip; but I think there are lot&amp;rsquo;s of situations where a script like this can be usefull:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
while [ 1 -ge 0 ]; do
time_begin=`date +%s`


###BLOCK 2 TRACK - BEGIN
number=$RANDOM
let &amp;quot;number %= 20&amp;quot;
sleep $number
###BLOCK 2 TRACK - END

time_end=`date +%s`
total=$((time_end-time_begin))

if [[ $total -ge 10 ]]; then
echo &amp;quot;time taken was: $number : $total&amp;quot;
else
echo &amp;quot;time take was too less  $number : $total&amp;quot;
sleep 10
fi
done
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>